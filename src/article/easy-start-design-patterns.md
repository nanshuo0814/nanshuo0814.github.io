---
title: 一文带你简单入门了解设计模式
date: 2024-05-17 15:51:30
cover: https://ypycdn.nanshuo.icu/posts/shejimoshi/sjmsfm.png
excerpt: 本文介绍了设计模式的定义、优点和六大原则，阐述了创建型、结构型和行为型三种类型的设计模式，包括其含义和适用场景，并给出了记忆口诀
#permalink: /archives/ag5BMMHE
isOriginal: true
star: true
category:
 - 设计模式
tag:
 - 设计模式
 - 结构型模式
 - 行为型模式
 - 创建型模式
---

# 什么是设计模式
设计模式是在软件开发中，经过实践总结出来的**可重复使用的、针对特定问题**的解决方案的模板。它对软件设计中常见的问题进行了**抽象和概括**，提供了一种标准化的设计**思路和方法**，以**提高软件的质量、可维护性、可扩展性和可复用性**。简单来说，设计模式是一种编程中的**经验总结和最佳实践**。
# 设计模式的优点

- **提高代码质量**：使代码结构更加清晰、合理和健壮。
- **增强可读性和可理解性**：遵循特定模式的代码更容易被其他人理解和掌握。
- **促进代码复用**：减少重复代码的编写，提高开发效率。
- **提高系统的灵活性和可扩展性**：可以方便地进行功能扩展和修改，而对其他部分影响较小。
- **增强系统的稳定性**：经过实践验证的模式有助于避免一些常见的错误和问题。
- **便于团队协作**：团队成员对设计模式有共同的认知，便于沟通和协作。
- **提升软件的可维护性**：使代码更易于维护和更新。
# 设计模式的六大原则

1. **单一职责原则**：一个类应该只有一个引起它变化的原因，即一个类只负责一项职责。
2. **开放-封闭原则**：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。
3. **里氏替换原则**：在任何使用父类的地方都可以用其子类来替换。
4. **依赖倒置原则**：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
5. **接口隔离原则**：客户端不应该被迫依赖于它不使用的接口。
6. **迪米特法则**：一个对象应该对其他对象保持最少的了解。
# 设计模式的三种类型
## 创建型模式
创建型模式是设计模式中的一类，它主要**关注对象的创建机制**。
创建型模式的核心在于将对象的创建过程进行**抽象和封装**，使得系统在创建对象时**更加灵活、高效且可维护**。这些模式提供了不同的方式来实例化对象，以适应各种不同的场景和需求。 它们可以帮助解决对象创建过程中的一些常见问题，比如如何避免对象创建的代码重复、如何根据不同的条件创建不同类型的对象、如何更好地控制对象创建的细节和时机等。通过使用创建型模式，能够使软件的架构更加清晰合理，提高代码的**可扩展性和可复用性**。常见的创建型模式包括**单例模式、工厂模式、抽象工厂模式、原型模式、建造者模式**等。
**记忆口诀**：创原工抽建单（**创员工抽检单**）
解释：创（创建型模式）原（原型模式）工（工厂模式）抽（抽象工厂模式）建（建造者模式）单（单例模式）

| 创建型模式 | 描述 |
| --- | --- |
| 单例模式 | 确保**一个类只有一个实例**，并提供一个全局访问点。 |
| 工厂模式 | 定义一个用于创建对象的接口，让子类决定实例化哪一个类 |
| 抽象工厂模式 | 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 |
| 原型模式 | 将一个**对象作为原型**，通过对其**进行复制而克隆**出多个和原型类似的新实例 |
| 建造者模式 | 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，**可简单理解为对复杂 对象进行分模块构建** |

## 结构型模式
结构型模式是设计模式的一类，主要**关注**如何将不同的类和对象组合成更大的**结构**，以**实现**特定的**功能和架构**。 它侧重于处理**类和对象**之间的**组合关系**，通过合理的结构设计来增强系统的**灵活性、可扩展性和可维护性**。这些模式帮助解决在构建复杂系统时，不同组件之间如何更好地协同工作、如何构建更清晰合理的层次结构等问题。 例如，适配器模式解决了不兼容接口之间的适配问题；组合模式构建了层次化的组合结构；桥接模式分离了抽象与实现等。结构型模式使得系统在面对变化和扩展时，能够更从容地进行调整和重构，保持系统的**稳定性和健壮性**。
**记忆口诀**：结享桥装，适代外组（**姐想乔装，试戴崴足**）
解释：结（结构型模式）享（享元模式）桥（桥接模式）装（装饰器模式），适（适配器模式）代（代理模式）外（外观模式）组（组合模式）

| 结构型模式 | 描述 |
| --- | --- |
| 适配器模式 | 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作，将一个类的**接口转换**成客户希望的另外一个接口 |
| 桥接模式 | 将**抽象部分**与它的**实现部分分离**，使它们都可以**独立地变化** |
| 组合模式 | 将对象组合成树形结构以表示“**部分-整体**”的层次结构。 |
| 装饰器模式 | **动态**地给一个**对象添加**一些**额外的职责** |
| 外观模式 | 为复杂的子系统**提供一个简单统一的接口**，隐藏了子系统内部的复杂性，让客户端与子系统的交互变得更简单和直接 |
| 享元模式 | 运用共享技术有效地**支持大量细粒度的对象** |
| 代理模式 | 为其他对象**提供**一种**代理**以**控制**对这个**对象的访问**，从而限制、增强或修改该对象的一些特性 |

## 行为型模式
行为型模式是设计模式中的一类，主要关注**对象之间的交互和职责分配**。
行为型模式侧重于描述对象在运行时的行为以及它们之间如何**协作、通信和完成特定任务**。这些模式帮助解决在复杂系统中对象之间的动态交互问题，使得系统的行为更加灵活、可扩展和易于理解。 常见的行为型模式包括**策略模式、模板方法模式、观察者模式、迭代器模式、命令模式、状态模式、中介者模式、备忘录模式、责任链模式、解释器模式、访问者模式**等。它们通过定义明确的**行为规则和交互方式**，来优化系统中对象的行为表现，提高系统的整体质量和可维护性。
**记忆口诀**：行责命迭状中，备解观策模访（**行者鸣笛撞钟，八戒观测模仿**）
解释：行（行为型模式）责（责任链模式）命（命令模式）迭（迭代器模式）状（状态模式）中（中介者模式）备（备忘录模式）解（解释器模式）观（观察者模式）策（策略模式）模（模板方法模式）访（访问者模式）

| 行为型模式 | 描述 |
| --- | --- |
| 策略模式 | 定义一系列算法，将每个算法**封装**起来，并让它们可以**相互替换**，**同一功能的不同实现** |
| 模板方法模式 | 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得**子类可以不改变该算法结构的情况下重定义该算法**的某些特定步骤 |
| 观察者模式 | 定义对象间的一种**一对多的依赖关系**，当**一个对象**状态**发生改变**时，所有**依赖**它的对象都得到**通知并自动更新**，常见的是：**发布-订阅** |
| 迭代器模式 | 提供一种方法**顺序访问（遍历）**一个聚合对象中各个元素，而又不需暴露该对象的内部表示 |
| 命令模式 | 将一个**请求封装为一个对象**，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作 |
| 状态模式 | 允许一个对象在其内部状态改变时改变它的行为，常见场景为：**一个对象的行为取决于它的状态** |
| 备忘录模式 | 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该**对象之外保存这个状态**，以便以后**恢复**到这一状态，**撤销-恢复** |
| 中介者模式 | 定义一个**中介对象**来**简化原有对象**之间的**交互关系**，降低系统中对象间的耦合度，使**原有对象**之间**不必相互了解** |
| 解释器模式 | 给定一个语言，定义它的**文法**的一种表示，并定义一个解释器，这个**解释器使用该表示来解释语言中的句子** |
| 责任链模式 | 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些**对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止** |
| 访问者模式 | 在不改变数据结构元素的前提下，**为一个数据结构中的每个元素提供多种访问方式** |
